# FilRelex API

## Overview

FilRelex is a comprehensive Filipino-English dictionary API featuring rich linguistic data, including Baybayin script support, word relationships, etymologies, and advanced search capabilities. This backend service provides a RESTful API for accessing and manipulating dictionary data.

## Table of Contents

- [Installation](#installation)
- [Configuration](#configuration)
- [Running the API](#running-the-api)
- [API Endpoints](#api-endpoints)
  - [Word Operations](#word-operations)
  - [Search](#search)
  - [Baybayin](#baybayin)
  - [Relationships](#relationships)
  - [Statistics](#statistics)
  - [Import/Export](#importexport)
  - [Quality Assessment](#quality-assessment)
- [Database Schema](#database-schema)
- [Development](#development)
- [Testing](#testing)
- [Deployment](#deployment)
- [Contributing](#contributing)

## Installation

### Prerequisites

- Python 3.9+
- PostgreSQL 13+
- Redis (optional, for caching and rate limiting)

### Setup

1. Clone the repository:
   ```bash
   git clone https://github.com/your-org/fil-relex.git
   cd fil-relex/backend
   ```

2. Create a virtual environment:
   ```bash
   python -m venv venv
   source venv/bin/activate  # On Windows: venv\Scripts\activate
   ```

3. Install dependencies:
   ```bash
   pip install -r requirements.txt
   ```

4. Set up the database:
   ```bash
   python create_database.py
   ```

5. Run migrations:
   ```bash
   python -m flask db upgrade
   ```

## Configuration

Configuration is handled through environment variables or a `.env` file. Key configuration options include:

```
# Database settings
DATABASE_URL=postgresql://postgres:postgres@localhost:5432/fil_dict_db
DB_MIN_CONNECTIONS=5
DB_MAX_CONNECTIONS=20
DB_POOL_TIMEOUT=30
DB_POOL_RECYCLE=1800

# Redis settings (optional)
REDIS_ENABLED=false
REDIS_URL=redis://localhost:6379/0

# Application settings
SECRET_KEY=your-secret-key
ENVIRONMENT=development # or production
DEBUG=true
LOG_LEVEL=INFO

# Rate limiting
RATELIMIT_DEFAULT=200 per minute
RATELIMIT_STORAGE_URI=memory://
```

## Running the API

### Development Server

```bash
python serve.py
```

Or using Flask directly:

```bash
flask run --host=0.0.0.0 --port=5000
```

### Production Server

For production, we recommend using Gunicorn with Nginx:

```bash
gunicorn --bind 0.0.0.0:5000 "backend:create_app()" --workers 4 --threads 2
```

## API Endpoints

### Word Operations

#### GET /api/v2/words/{word_id}
Retrieve a word by its ID.

**Parameters:**
- `include_definitions` (boolean, default: true)
- `include_pronunciations` (boolean, default: true)
- `include_etymologies` (boolean, default: true)
- `include_relations` (boolean, default: true)
- `include_forms` (boolean, default: true)
- `include_templates` (boolean, default: true)
- `include_metadata` (boolean, default: true)

**Example Response:**
```json
{
  "id": 1234,
  "lemma": "halimbawa",
  "language_code": "fil",
  "pos": "n",
  "has_baybayin": true,
  "baybayin_form": "ᜑᜎᜒᜋ᜔ᜊᜏ",
  "definitions": [
    {
      "id": 5678,
      "definition_text": "An example or sample of something.",
      "examples": ["Mabigyan mo nga ako ng halimbawa."]
    }
  ],
  "completeness_score": 0.85
}
```

#### GET /api/v2/words
Get a list of words with pagination.

**Parameters:**
- `language_code` (string): Filter by language code
- `pos` (string): Filter by part of speech
- `limit` (integer, default: 50): Maximum number of results
- `offset` (integer, default: 0): Number of results to skip

#### GET /api/v2/random
Get a random word from the dictionary.

**Parameters:**
- `language` (string): Filter by language code
- `pos` (string): Filter by part of speech
- `has_etymology` (boolean): Filter for words with etymologies
- `has_baybayin` (boolean): Filter for words with Baybayin form
- `min_definitions` (integer): Minimum number of definitions

#### POST /api/v2/words
Create a new word.

**Request Body:**
```json
{
  "lemma": "bagong_salita",
  "language_code": "fil",
  "pos": "n",
  "has_baybayin": true,
  "baybayin_form": "ᜊᜄᜓᜅ᜔ᜐᜎᜒᜆ",
  "definitions": [
    {
      "definition_text": "A new word added to the dictionary.",
      "examples": ["Ito ay isang bagong_salita."]
    }
  ]
}
```

#### PUT /api/v2/words/{word_id}
Update an existing word.

#### DELETE /api/v2/words/{word_id}
Delete a word from the dictionary.

### Search

#### GET /api/v2/search
Search for words based on query text.

**Parameters:**
- `q` (string, required): Search query
- `mode` (string, default: "all"): Search mode ("all", "exact", "prefix", "suffix")
- `limit` (integer, default: 50): Maximum number of results
- `offset` (integer, default: 0): Number of results to skip
- `sort` (string, default: "relevance"): Sort order
- `order` (string, default: "desc"): Sort direction ("asc", "desc")
- `include_full` (boolean, default: false): Include full word details

**Example Request:**
```
GET /api/v2/search?q=bahay&mode=exact&limit=10
```

**Example Response:**
```json
{
  "count": 1,
  "results": [
    {
      "id": 456,
      "lemma": "bahay",
      "language_code": "fil",
      "pos": "n",
      "has_baybayin": true,
      "baybayin_form": "ᜊᜑᜌ᜔",
      "definitions": [
        {
          "definition_text": "A house or home.",
          "examples": ["Malaki ang bahay nila."]
        }
      ]
    }
  ]
}
```

#### GET /api/v2/search/advanced
Advanced search with additional filtering capabilities.

**Parameters:**
- All parameters from regular search
- `min_completeness` (float): Minimum completeness score (0-1)
- `max_completeness` (float): Maximum completeness score (0-1)
- `date_added_from` (datetime): Filter by creation date
- `date_added_to` (datetime): Filter by creation date
- `date_modified_from` (datetime): Filter by modification date
- `date_modified_to` (datetime): Filter by modification date
- `min_definition_count` (integer): Minimum definition count
- `max_definition_count` (integer): Maximum definition count
- `min_relation_count` (integer): Minimum relation count
- `max_relation_count` (integer): Maximum relation count
- `has_etymology` (boolean): Filter for words with etymologies
- `has_baybayin` (boolean): Filter for words with Baybayin form
- `has_pronunciation` (boolean): Filter for words with pronunciation
- `has_forms` (boolean): Filter for words with forms

#### GET /api/v2/search/suggestions
Get search suggestions for autocomplete functionality.

**Parameters:**
- `q` (string, required): Partial query for suggestions
- `limit` (integer, default: 10): Maximum number of suggestions
- `language` (string): Filter by language code

### Baybayin

#### GET /api/v2/baybayin/search
Search for words with specific Baybayin characters.

**Parameters:**
- `query` (string, required): Baybayin search query (must contain Baybayin characters)
- `language_code` (string): Filter by language
- `limit` (integer, default: 50): Maximum results
- `offset` (integer, default: 0): Pagination offset

**Example Request:**
```
GET /api/v2/baybayin/search?query=ᜊ&language_code=fil&limit=20
```

**Example Response:**
```json
{
  "count": 42,
  "results": [
    {
      "id": 123,
      "lemma": "baka",
      "language_code": "fil",
      "baybayin_form": "ᜊᜃ",
      "pos": "n",
      "completeness_score": 0.75
    }
  ]
}
```

#### GET /api/v2/baybayin/statistics
Get detailed statistics about Baybayin usage in the dictionary.

**Example Response:**
```json
{
  "overview": {
    "total_words": 15000,
    "with_baybayin": 3500,
    "percentage": 23.33
  },
  "by_language": [
    {
      "language_code": "fil",
      "total_words": 12000,
      "with_baybayin": 3200,
      "percentage": 26.67
    }
  ],
  "character_frequency": {
    "fil": {
      "ᜀ": 956,
      "ᜁ": 450,
      "ᜂ": 325
    }
  },
  "completeness": {
    "with_baybayin": 0.78,
    "without_baybayin": 0.62
  }
}
```

#### POST /api/v2/baybayin/convert
Convert romanized text to Baybayin script.

**Request Body:**
```json
{
  "text": "Magandang umaga",
  "language_code": "fil"
}
```

**Response:**
```json
{
  "original_text": "Magandang umaga",
  "baybayin_text": "ᜋᜄᜈ᜔ᜇᜅ᜔ ᜂᜋᜄ",
  "conversion_rate": 1.0
}
```

### Relationships

#### GET /api/v2/words/{word_id}/relations
Get all relationships for a word.

**Parameters:**
- `relation_type` (string): Filter by relation type
- `direction` (string, default: "all"): Relation direction ("incoming", "outgoing", "all")

#### POST /api/v2/relations
Create a new relationship between words.

**Request Body:**
```json
{
  "source_id": 123,
  "target_id": 456,
  "relation_type": "synonym",
  "weight": 1.0,
  "notes": "These words are direct synonyms"
}
```

#### GET /api/v2/words/{word_id}/semantic_network
Get a semantic network of related words.

**Parameters:**
- `depth` (integer, default: 2): Depth of relations to traverse
- `max_nodes` (integer, default: 50): Maximum nodes to return
- `include_definitions` (boolean, default: true): Include definitions

#### GET /api/v2/words/{word_id}/affixations
Get affixation relationships for a word.

#### GET /api/v2/relationships/types
Get available relationship types.

### Statistics

#### GET /api/v2/statistics
Get basic dictionary statistics.

**Example Response:**
```json
{
  "total_words": 25000,
  "total_definitions": 42000,
  "words_with_etymology": 8500,
  "words_with_baybayin": 3500,
  "words_by_language": {
    "fil": 20000,
    "ceb": 5000
  }
}
```

#### GET /api/v2/statistics/advanced
Get detailed dictionary statistics.

**Response includes:**
- Word counts by language, part of speech
- Definition statistics
- Relation statistics
- Completeness metrics
- Etymology coverage
- Baybayin coverage

#### GET /api/v2/statistics/timeseries
Get time-series statistics showing dictionary growth over time.

**Parameters:**
- `start_date` (date): Start of time range
- `end_date` (date): End of time range
- `interval` (string, default: "month"): Time interval ("day", "week", "month", "year")

**Example Response:**
```json
{
  "timeline": [
    {
      "date": "2022-01-01",
      "word_count": 20000,
      "definition_count": 35000,
      "baybayin_count": 2500
    },
    {
      "date": "2022-02-01",
      "word_count": 21000,
      "definition_count": 36500,
      "baybayin_count": 2800
    }
  ],
  "growth_rates": {
    "words": 5.0,
    "definitions": 4.3,
    "baybayin": 12.0
  }
}
```

#### GET /api/v2/statistics/language/{language_code}
Get detailed statistics for a specific language.

### Import/Export

#### GET /api/v2/export
Export dictionary data with filtering options.

**Parameters:**
- `language_code` (string): Filter by language
- `pos` (string): Filter by part of speech
- `has_baybayin` (boolean): Filter for words with Baybayin
- `min_completeness` (float): Minimum completeness score
- `created_after` (datetime): Filter by creation date
- `created_before` (datetime): Filter by creation date
- `updated_after` (datetime): Filter by modification date
- `updated_before` (datetime): Filter by modification date
- `format` (string, default: "json"): Export format ("json", "csv", "zip")
- `limit` (integer, default: 5000): Maximum number of records to export
- `offset` (integer, default: 0): Number of records to skip

#### POST /api/v2/import
Import dictionary data.

**Request Body:**
- Multipart form data with file upload
- JSON configuration for import settings

### Quality Assessment

#### GET /api/v2/quality_assessment
Analyze dictionary data quality, completeness, and identify issues.

**Parameters:**
- `language_code` (string): Filter by language
- `pos` (string): Filter by part of speech
- `min_completeness` (float): Minimum completeness score
- `max_completeness` (float): Maximum completeness score
- `issue_severity` (string, default: "all"): Filter by issue severity ("all", "critical", "warning", "info")
- `max_results` (integer, default: 100): Maximum number of issues to return

## Database Schema

The FilRelex database uses a relational schema with the following main tables:

- `words`: Core word entries
- `definitions`: Word definitions with examples
- `word_relations`: Relationships between words
- `etymologies`: Etymology information
- `pronunciations`: Pronunciation data
- `word_forms`: Inflected forms of words

For a complete schema, see the [database.py](./database.py) and [models.py](./models.py) files.

## Development

### Code Structure

- `app.py`: Main Flask application configuration
- `routes.py`: API endpoint definitions
- `baybayin_routes.py`: Baybayin-specific endpoints
- `database.py`: Database models and connection management
- `schema.py`: Request/response schemas using Marshmallow
- `security.py`: Authentication and security middleware
- `monitoring.py`: Logging and metrics collection

### Adding New Endpoints

1. Define your endpoint function in `routes.py` or an appropriate module
2. Add any required schemas in `schema.py`
3. Register the endpoint with the Flask blueprint
4. Update this documentation to reflect the new endpoint

### Coding Standards

- Follow PEP 8 style guidelines
- Write docstrings for all functions and classes
- Include type hints
- Write unit tests for new functionality

## Testing

### Running Tests

```bash
python run_tests.py
```

Or using pytest directly:

```bash
pytest
```

### Test Coverage

Generate a test coverage report:

```bash
python -m pytest --cov=backend tests/
```

## Deployment

### Docker

A Dockerfile is provided for containerized deployment:

```bash
docker build -t fil-relex-api .
docker run -p 5000:5000 fil-relex-api
```

### Docker Compose

For a complete development environment with PostgreSQL and Redis:

```bash
docker-compose up -d
```

### Production Deployment

For production deployments, we recommend:

1. Running behind Nginx or Apache as a reverse proxy
2. Using Gunicorn or uWSGI as the WSGI server
3. Enabling SSL/TLS
4. Configuring appropriate rate limits
5. Setting up monitoring and alerting

See the [deploy](./deploy) directory for deployment scripts and configurations.

## Contributing

### Submitting Pull Requests

1. Fork the repository
2. Create a new branch for your feature
3. Add your changes
4. Write tests for your changes
5. Run the test suite to ensure everything passes
6. Submit a pull request

### Reporting Issues

Please report issues using the issue tracker on GitHub, including:

- A clear description of the issue
- Steps to reproduce
- Expected behavior
- Actual behavior
- Any relevant logs or error messages

---

## License

Copyright © 2023 FilRelex Team. All rights reserved.

## Error Handling

The FilRelex API uses standard HTTP status codes to indicate the success or failure of requests:

| Status Code | Description |
|-------------|-------------|
| 200 | Success - The request was successfully processed |
| 400 | Bad Request - The request could not be understood or was missing required parameters |
| 401 | Unauthorized - Authentication failed or user does not have permissions |
| 403 | Forbidden - The request is understood but has been refused or access is not allowed |
| 404 | Not Found - The requested resource could not be found |
| 422 | Unprocessable Entity - The request was well-formed but was unable to be followed |
| 429 | Too Many Requests - Rate limit exceeded |
| 500 | Internal Server Error - Something went wrong on the server |

Error responses include detailed information in a consistent format:

```json
{
  "error": "Error type or code",
  "message": "A human-readable error message with details",
  "details": {
    "parameter": "The specific parameter causing the error",
    "reason": "The specific reason for the error"
  },
  "request_id": "a-unique-request-identifier-for-troubleshooting"
}
```

### Common Error Scenarios

1. **Missing Required Parameters**
   ```json
   {
     "error": "missing_parameter",
     "message": "Required parameter 'q' is missing",
     "details": {"parameter": "q"}
   }
   ```

2. **Validation Errors**
   ```json
   {
     "error": "validation_error",
     "message": "Invalid parameter value",
     "details": {
       "parameter": "min_completeness",
       "reason": "Value must be between 0.0 and 1.0"
     }
   }
   ```

3. **Resource Not Found**
   ```json
   {
     "error": "not_found",
     "message": "Word with ID 12345 not found"
   }
   ```

4. **Rate Limiting**
   ```json
   {
     "error": "rate_limit_exceeded",
     "message": "Rate limit exceeded. Please try again later.",
     "details": {
       "limit": "200 per minute",
       "reset_at": "2023-06-10T15:30:45Z"
     }
   }
   ```

## Authentication and Authorization

Currently, the FilRelex API uses IP-based rate limiting without requiring authentication. However, we plan to implement authentication in a future release.

### Future Authentication Plans

We plan to implement two authentication methods:

1. **API Key Authentication**
   Basic authentication for public endpoints with higher rate limits than unauthenticated requests.

2. **OAuth 2.0**
   For more sensitive operations and partner integrations.

Example future implementation:

```bash
# API Key Authentication
curl -X GET "https://api.fil-relex.example.com/api/v2/search?q=bahay" \
  -H "X-API-Key: your_api_key_here"

# OAuth 2.0 Authentication
curl -X GET "https://api.fil-relex.example.com/api/v2/words" \
  -H "Authorization: Bearer your_oauth_token_here"
```

We will update this documentation when authentication is implemented.

## Examples in Multiple Languages

### Python

```python
import requests

API_BASE = "https://api.fil-relex.example.com/api/v2"

def search_words(query, mode="all", limit=10):
    """Search for words in the dictionary."""
    response = requests.get(
        f"{API_BASE}/search",
        params={"q": query, "mode": mode, "limit": limit}
    )
    response.raise_for_status()
    return response.json()

def get_word_details(word_id):
    """Get details for a specific word."""
    response = requests.get(f"{API_BASE}/words/{word_id}")
    response.raise_for_status()
    return response.json()

def convert_to_baybayin(text, language_code="fil"):
    """Convert text to Baybayin script."""
    response = requests.post(
        f"{API_BASE}/baybayin/convert",
        json={"text": text, "language_code": language_code}
    )
    response.raise_for_status()
    return response.json()
```

### JavaScript

```javascript
const API_BASE = "https://api.fil-relex.example.com/api/v2";

// Search for words
async function searchWords(query, mode = "all", limit = 10) {
  const response = await fetch(
    `${API_BASE}/search?q=${encodeURIComponent(query)}&mode=${mode}&limit=${limit}`
  );
  
  if (!response.ok) {
    throw new Error(`API error: ${response.status}`);
  }
  
  return await response.json();
}

// Get word details
async function getWordDetails(wordId) {
  const response = await fetch(`${API_BASE}/words/${wordId}`);
  
  if (!response.ok) {
    throw new Error(`API error: ${response.status}`);
  }
  
  return await response.json();
}

// Convert text to Baybayin
async function convertToBaybayin(text, languageCode = "fil") {
  const response = await fetch(`${API_BASE}/baybayin/convert`, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ text, language_code: languageCode })
  });
  
  if (!response.ok) {
    throw new Error(`API error: ${response.status}`);
  }
  
  return await response.json();
}
```

### PHP

```php
<?php
$API_BASE = "https://api.fil-relex.example.com/api/v2";

function searchWords($query, $mode = "all", $limit = 10) {
  $url = $API_BASE . "/search?q=" . urlencode($query) . "&mode=" . $mode . "&limit=" . $limit;
  
  $ch = curl_init();
  curl_setopt($ch, CURLOPT_URL, $url);
  curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);
  
  $response = curl_exec($ch);
  $statusCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);
  curl_close($ch);
  
  if ($statusCode !== 200) {
    throw new Exception("API error: " . $statusCode);
  }
  
  return json_decode($response, true);
}

function getWordDetails($wordId) {
  $url = $API_BASE . "/words/" . $wordId;
  
  $ch = curl_init();
  curl_setopt($ch, CURLOPT_URL, $url);
  curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);
  
  $response = curl_exec($ch);
  $statusCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);
  curl_close($ch);
  
  if ($statusCode !== 200) {
    throw new Exception("API error: " . $statusCode);
  }
  
  return json_decode($response, true);
}
?>
```

## Pagination

The FilRelex API uses offset-based pagination for endpoints that return collections of resources. The following parameters control pagination:

- `limit`: The maximum number of items to return (default varies by endpoint)
- `offset`: The number of items to skip (default: 0)

For paginated responses, the following metadata is included in the response:

```json
{
  "count": 1250,  // Total number of available items
  "results": [    // The items for this page
    ...
  ]
}
```

### Example Pagination

To get the first page of search results (items 1-50):
```
GET /api/v2/search?q=bahay&limit=50&offset=0
```

To get the second page (items 51-100):
```
GET /api/v2/search?q=bahay&limit=50&offset=50
```

### Pagination Headers

The following headers are included in paginated responses:

- `X-Total-Count`: The total number of items available
- `Content-Range`: The range of items returned (e.g., `items 0-49/1250`)

## Versioning Strategy

The FilRelex API uses URL versioning to ensure backward compatibility as the API evolves.

### Current Version

The current version is `v2`, which is reflected in the API base URL:
```
https://api.fil-relex.example.com/api/v2
```

### Versioning Policies

1. **Breaking Changes**: When we make breaking changes to the API, we will increment the major version number (e.g., from `v2` to `v3`).
2. **Backward Compatibility**: We ensure that older versions remain available for a deprecation period of at least 6 months.
3. **Non-Breaking Changes**: We may add new features to the current version without incrementing the version number, as long as these changes are backward compatible.

### Version Support Timeline

| Version | Status | Support Ends |
|---------|--------|--------------|
| v1      | Deprecated | 2023-12-31 |
| v2      | Current    | Active |

### Version Headers

You can specify a specific version using the `Accept` header:
```
Accept: application/json; version=2
```

## Response Headers

The FilRelex API includes the following custom headers in responses:

### Standard Headers

- `Content-Type`: The MIME type of the response (typically `application/json`)
- `Content-Length`: The length of the response body in bytes

### Rate Limiting Headers

- `X-RateLimit-Limit`: The maximum number of requests allowed in the current period
- `X-RateLimit-Remaining`: The number of requests remaining in the current period
- `X-RateLimit-Reset`: The time in seconds until the rate limit resets

### Caching Headers

- `ETag`: A unique identifier for the current version of a resource
- `Cache-Control`: Directives for caching the response
- `Last-Modified`: The date and time the resource was last modified

### Request Identification

- `X-Request-ID`: A unique identifier for the request, useful for troubleshooting

## CORS Policies

The FilRelex API supports Cross-Origin Resource Sharing (CORS) to allow browser-based applications to securely access the API.

### Allowed Origins

In development, all origins are allowed. In production, only whitelisted domains are permitted.

### Allowed Methods

The following HTTP methods are supported for CORS requests:
- GET
- POST
- PUT
- DELETE
- OPTIONS

### Allowed Headers

The following headers are supported for CORS requests:
- Content-Type
- Authorization
- X-Requested-With
- X-API-Key

### CORS Response Headers

The following headers are included in CORS responses:
- Access-Control-Allow-Origin
- Access-Control-Allow-Methods
- Access-Control-Allow-Headers
- Access-Control-Expose-Headers
- Access-Control-Max-Age

### Credentials

CORS requests with credentials (cookies) are supported for authenticated endpoints.

## Webhooks

The FilRelex API supports webhooks for event-based notifications. This feature allows integration partners to receive real-time updates when certain events occur in the system.

### Available Events

| Event Type | Description |
|------------|-------------|
| word.created | A new word is added to the dictionary |
| word.updated | An existing word is updated |
| word.deleted | A word is deleted from the dictionary |
| relation.created | A new relationship is created between words |
| relation.deleted | A relationship between words is deleted |

### Webhook Registration

To register a webhook, make a POST request to the webhook registration endpoint:

```
POST /api/v2/webhooks
```

**Request Body:**
```json
{
  "url": "https://your-application.com/webhook-handler",
  "events": ["word.created", "word.updated"],
  "secret": "your-webhook-secret"
}
```

### Webhook Payload

When an event occurs, the FilRelex API will send a POST request to your specified URL with the following payload:

```json
{
  "event_type": "word.created",
  "event_id": "evt_123456789",
  "timestamp": "2023-06-10T12:34:56Z",
  "data": {
    "word_id": 12345,
    "lemma": "bagong_salita",
    "language_code": "fil"
  }
}
```

### Webhook Security

To verify that a webhook request is genuinely from the FilRelex API, we include a signature in the `X-FilRelex-Signature` header. This signature is an HMAC-SHA256 hash of the request body, using your webhook secret as the key.

## Changelog

### v2.1.0 (2023-06-10)

- Added new Baybayin-specific endpoints (/baybayin/search, /baybayin/statistics, /baybayin/convert)
- Enhanced advanced filtering capabilities for search
- Added statistical analysis endpoints
- Improved error handling with more detailed error messages
- Performance optimizations for large result sets

### v2.0.0 (2023-01-15)

- Complete API redesign with a RESTful architecture
- Added comprehensive word relationship support
- Introduced completeness scoring for dictionary entries
- Added support for etymologies and pronunciations
- Improved search capabilities with multiple modes

### v1.3.0 (2022-08-22)

- Added support for Baybayin script
- Enhanced filtering options
- Improved pagination

### v1.0.0 (2022-01-10)

- Initial release of the FilRelex API
- Basic dictionary functionality
- Simple search capabilities

## Troubleshooting Guide

### Common Issues

#### 1. Rate Limiting

**Issue**: Receiving 429 Too Many Requests errors.

**Solution**: 
- Reduce the frequency of requests
- Implement exponential backoff between retries
- Check the `X-RateLimit-Reset` header to determine when to resume requests

#### 2. Search Returns Unexpected Results

**Issue**: Search queries aren't returning expected words.

**Solutions**:
- Check the search mode parameter (try "all" instead of "exact")
- Ensure special characters are properly URL-encoded
- Try using normalized forms of words without diacritical marks

#### 3. Incomplete Word Data

**Issue**: Word details are missing certain fields.

**Solution**:
- Check the include_* parameters in your request (e.g., include_definitions, include_etymologies)
- Some words may have incomplete data; check the completeness_score field
- Filter by minimum completeness using min_completeness parameter

#### 4. Large Responses Timing Out

**Issue**: Requests for large data sets time out.

**Solution**:
- Use pagination parameters (limit and offset) to request smaller chunks of data
- Use more specific filters to narrow your results
- Consider using the export endpoint for bulk data retrieval

### Error Code Reference

| Error Code | Description | Troubleshooting Step |
|------------|-------------|---------------------|
| invalid_parameter | Parameter value is invalid | Check API documentation for valid values |
| missing_parameter | Required parameter is missing | Ensure all required parameters are included |
| resource_not_found | Requested resource not found | Verify the ID or identifier being used |
| rate_limit_exceeded | Too many requests | Implement backoff and retry logic |
| server_error | Unexpected server error | Contact support with the request ID |

### Debugging Tips

1. **Request IDs**: Always include the `X-Request-ID` from error responses when seeking support
2. **Verbose Logging**: Set `verbose=true` in your requests during development for more detailed error information
3. **Test Environment**: Use our sandbox environment for testing at `https://sandbox-api.fil-relex.example.com/api/v2`

## Performance Expectations

### Response Times

| Endpoint Type | Average Response Time | 95th Percentile |
|---------------|------------------------|----------------|
| Single resource (e.g., /words/{id}) | < 100ms | < 200ms |
| Search (simple) | < 150ms | < 300ms |
| Search (complex/advanced) | < 300ms | < 600ms |
| Baybayin conversion | < 200ms | < 400ms |
| Batch operations | < 500ms | < 1000ms |
| Export (large datasets) | < 5s | < 15s |

### Rate Limits

| Endpoint | Unauthenticated | Authenticated |
|----------|------------------|---------------|
| Standard endpoints | 200/minute | 1000/minute |
| Search | 20/minute | 100/minute |
| Advanced search | 10/minute | 50/minute |
| Baybayin conversion | 30/minute | 150/minute |
| Export/Import | 5/hour | 20/hour |

### Service Level Agreement (SLA)

For production integrations, we target:
- 99.9% uptime
- Maximum 1-hour resolution time for critical issues
- Scheduled maintenance windows announced 72 hours in advance

### Caching

We implement caching with the following default TTLs:
- Dictionary entries: 1 hour
- Search results: 10 minutes
- Statistical data: 24 hours

You can bypass the cache by adding `no_cache=true` to your request.

## Security Recommendations

### Best Practices for API Integration

1. **Store API Keys Securely**
   - Never hardcode API keys in client-side code
   - Use environment variables or secure credential stores
   - Rotate keys periodically

2. **Implement Proper Error Handling**
   - Don't expose API errors directly to users
   - Implement graceful degradation when the API is unavailable
   - Log errors for debugging but sanitize sensitive information

3. **Use HTTPS for All Requests**
   - Never make API calls over unencrypted HTTP
   - Validate SSL certificates
   - Be aware of man-in-the-middle attack vectors

4. **Rate Limiting and Backoff**
   - Implement intelligent retries with exponential backoff
   - Cache results where appropriate to reduce API calls
   - Monitor your usage to avoid hitting rate limits

5. **Input Validation**
   - Validate and sanitize all input before passing to the API
   - Be cautious with user-supplied data in search queries
   - Use parameterized queries instead of string concatenation

6. **Output Encoding**
   - Always encode API responses before displaying to users
   - Be especially careful with Baybayin text rendering
   - Implement proper escaping for different contexts (HTML, JavaScript, etc.)

7. **Minimize Data Exposure**
   - Only request the data you need using the include_* parameters
   - Avoid storing sensitive linguistic data unnecessarily
   - Implement proper access controls in your application

### Security Notifications

Subscribe to our security mailing list at security@fil-relex.example.com to receive notifications about:
- Security vulnerabilities
- API changes that might affect security
- Best practice updates
